package bundler

import (
	"strings"
	"testing"
)

func TestGenerateBundle(t *testing.T) {
	b, _ := NewBundler("test.lua", false)

	// Add some test modules
	b.modules["./helper.lua"] = `local helper = {}
function helper.greet()
    return "Hello"
end
return helper`

	b.modules["https://example.com/remote.lua"] = `local remote = {}
function remote.fetch()
    return "data"
end
return remote`

	mainContent := `local helper = require('./helper.lua')
local remote = loadstring(game:HttpGet('https://example.com/remote.lua'))()

print(helper.greet())
print(remote.fetch())`

	result := b.generateBundle(mainContent)

	tests := []struct {
		name    string
		check   func(string) bool
		message string
	}{
		{
			name: "contains bundle header",
			check: func(s string) bool {
				return strings.Contains(s, "-- Bundled Lua Script") &&
					strings.Contains(s, "-- Generated by Lua Bundler")
			},
			message: "should contain bundle header",
		},
		{
			name: "contains EmbeddedModules table",
			check: func(s string) bool {
				return strings.Contains(s, "local EmbeddedModules = {}")
			},
			message: "should contain EmbeddedModules table",
		},
		{
			name: "contains loadModule function",
			check: func(s string) bool {
				return strings.Contains(s, "local function loadModule(url)")
			},
			message: "should contain loadModule function",
		},
		{
			name: "contains helper module",
			check: func(s string) bool {
				return strings.Contains(s, `EmbeddedModules["./helper.lua"]`) &&
					strings.Contains(s, "function helper.greet()")
			},
			message: "should contain helper module",
		},
		{
			name: "contains remote module",
			check: func(s string) bool {
				return strings.Contains(s, `EmbeddedModules["https://example.com/remote.lua"]`) &&
					strings.Contains(s, "function remote.fetch()")
			},
			message: "should contain remote module",
		},
		{
			name: "replaces require calls",
			check: func(s string) bool {
				return strings.Contains(s, `loadModule("./helper.lua")`) &&
					!strings.Contains(s, `require('./helper.lua')`)
			},
			message: "should replace require calls with loadModule",
		},
		{
			name: "replaces loadstring calls",
			check: func(s string) bool {
				return strings.Contains(s, `loadModule("https://example.com/remote.lua")`) &&
					!strings.Contains(s, `loadstring(game:HttpGet('https://example.com/remote.lua'))()`)
			},
			message: "should replace loadstring calls with loadModule",
		},
		{
			name: "contains main script section",
			check: func(s string) bool {
				return strings.Contains(s, "-- Main Script")
			},
			message: "should contain main script section",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !tt.check(result) {
				t.Errorf("generateBundle() %s\nGenerated bundle:\n%s", tt.message, result)
			}
		})
	}
}

func TestEscapeString(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "simple string",
			input:    "hello",
			expected: "hello",
		},
		{
			name:     "string with quotes",
			input:    `hello "world"`,
			expected: `hello \"world\"`,
		},
		{
			name:     "string with backslashes",
			input:    `path\to\file`,
			expected: `path\\to\\file`,
		},
		{
			name:     "string with both quotes and backslashes",
			input:    `"C:\Program Files\App"`,
			expected: `\"C:\\Program Files\\App\"`,
		},
		{
			name:     "empty string",
			input:    "",
			expected: "",
		},
		{
			name:     "URL with protocol",
			input:    "https://example.com/path?param=value",
			expected: "https://example.com/path?param=value",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := escapeString(tt.input)
			if result != tt.expected {
				t.Errorf("escapeString(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestGenerateBundle_EmptyModules(t *testing.T) {
	b, _ := NewBundler("test.lua", false)
	// No modules added

	mainContent := `print("Hello World")`

	result := b.generateBundle(mainContent)

	// Should still generate valid structure even with no modules
	if !strings.Contains(result, "local EmbeddedModules = {}") {
		t.Errorf("generateBundle() should contain EmbeddedModules table even with no modules")
	}

	if !strings.Contains(result, "local function loadModule(url)") {
		t.Errorf("generateBundle() should contain loadModule function even with no modules")
	}

	if !strings.Contains(result, "-- Main Script") {
		t.Errorf("generateBundle() should contain main script section")
	}

	if !strings.Contains(result, `print("Hello World")`) {
		t.Errorf("generateBundle() should contain original main content")
	}
}

func TestGenerateBundle_ModuleIndentation(t *testing.T) {
	b, _ := NewBundler("test.lua", false)

	moduleContent := `local test = {}

function test.method()
    if true then
        print("nested")
    end
end

return test`

	b.modules["test"] = moduleContent

	result := b.generateBundle("local t = require('test')")

	// Check that indentation is properly added (4 spaces for each line)
	lines := strings.Split(result, "\n")
	moduleStarted := false
	moduleEnded := false

	for _, line := range lines {
		if strings.Contains(line, `EmbeddedModules["test"] = function()`) {
			moduleStarted = true
			continue
		}

		if moduleStarted && !moduleEnded {
			if strings.TrimSpace(line) == "end" && !strings.HasPrefix(line, "    ") {
				moduleEnded = true
				continue
			}

			// Non-empty lines in module should be indented with 4 spaces
			if strings.TrimSpace(line) != "" {
				if !strings.HasPrefix(line, "    ") {
					t.Errorf("Module line should be indented with 4 spaces: %q", line)
				}
			}
		}
	}
}
