package main

import (
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

type Bundler struct {
	modules    map[string]string // path -> content
	baseDir    string
	httpClient *http.Client
}

func NewBundler(baseDir string) *Bundler {
	return &Bundler{
		modules: make(map[string]string),
		baseDir: baseDir,
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

func (b *Bundler) downloadHTTP(url string) (string, error) {
	fmt.Printf("Downloading: %s\n", url)

	resp, err := b.httpClient.Get(url)
	if err != nil {
		return "", fmt.Errorf("failed to download %s: %w", url, err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to download %s: status %d", url, resp.StatusCode)
	}

	content, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response from %s: %w", url, err)
	}

	return string(content), nil
}

func (b *Bundler) isLocalModule(modulePath string) bool {
	// Module dianggap lokal jika:
	// 1. Dimulai dengan "." (relatif)
	// 2. Dimulai dengan "/" (absolut dari base)
	// 3. Berisi "/" (subdirectory)
	// 4. Berakhir dengan ".lua"
	// 5. Tidak berisi karakter yang mengindikasikan external module (seperti titik untuk package)
	return strings.HasPrefix(modulePath, ".") ||
		strings.HasPrefix(modulePath, "/") ||
		strings.Contains(modulePath, "/") ||
		strings.HasSuffix(modulePath, ".lua") ||
		(!strings.Contains(modulePath, ".") && !strings.Contains(modulePath, "::"))
}

func (b *Bundler) resolveModulePath(currentFile, modulePath string) string {
	modulePath = strings.Trim(modulePath, "'\"")

	// Handle absolute paths from base directory
	if strings.HasPrefix(modulePath, "/") {
		resolvedPath := filepath.Join(b.baseDir, strings.TrimPrefix(modulePath, "/"))
		if !strings.HasSuffix(resolvedPath, ".lua") {
			resolvedPath += ".lua"
		}
		return resolvedPath
	}

	// Handle relative paths
	currentDir := filepath.Dir(currentFile)
	resolvedPath := filepath.Join(currentDir, modulePath)

	// Add .lua extension if not present
	if !strings.HasSuffix(resolvedPath, ".lua") {
		resolvedPath += ".lua"
	}

	// Clean the path to resolve .. and . components
	resolvedPath = filepath.Clean(resolvedPath)

	return resolvedPath
}

func (b *Bundler) processFile(filePath string, content string) error {
	// Regex patterns
	requireRegex := regexp.MustCompile(`require\s*\(\s*['"]([^'"]+)['"]\s*\)`)
	httpGetRegex := regexp.MustCompile(`loadstring\s*\(\s*game:HttpGet\s*\(\s*['"]([^'"]+)['"]\s*\)\s*\)\s*\(\s*\)`)

	lines := strings.Split(content, "\n")

	for _, line := range lines {
		// Cek untuk loadstring(game:HttpGet(...))()
		if matches := httpGetRegex.FindStringSubmatch(line); len(matches) > 1 {
			url := matches[1]

			// Skip jika sudah diproses
			if _, exists := b.modules[url]; exists {
				continue
			}

			// Download content dari URL
			httpContent, err := b.downloadHTTP(url)
			if err != nil {
				return err
			}

			b.modules[url] = httpContent

			// Proses content yang di-download (mungkin ada require di dalamnya)
			if err := b.processFile(url, httpContent); err != nil {
				return err
			}
		}

		// Cek untuk require() lokal
		if matches := requireRegex.FindStringSubmatch(line); len(matches) > 1 {
			modulePath := matches[1]

			// Proses file lokal (relatif, absolut dari base, atau subdirectory)
			if b.isLocalModule(modulePath) {
				resolvedPath := b.resolveModulePath(filePath, modulePath)

				// Skip jika sudah diproses
				if _, exists := b.modules[modulePath]; exists {
					continue
				}

				// Baca file lokal
				fileContent, err := os.ReadFile(resolvedPath)
				if err != nil {
					return fmt.Errorf("failed to read file %s: %w", resolvedPath, err)
				}

				b.modules[modulePath] = string(fileContent)

				// Proses file secara rekursif
				if err := b.processFile(resolvedPath, string(fileContent)); err != nil {
					return err
				}
			}
		}
	}

	return nil
}

func (b *Bundler) generateBundle(mainContent string) string {
	var output strings.Builder

	output.WriteString("-- Bundled Lua Script\n")
	output.WriteString("-- Generated by Lua Bundler\n\n")

	// Generate EmbeddedModules table
	output.WriteString("local EmbeddedModules = {}\n\n")

	// Add all modules
	for path, content := range b.modules {
		output.WriteString(fmt.Sprintf("-- Module: %s\n", path))
		output.WriteString(fmt.Sprintf("EmbeddedModules[\"%s\"] = function()\n", escapeString(path)))

		// Indent content
		lines := strings.Split(content, "\n")
		for _, line := range lines {
			if strings.TrimSpace(line) != "" {
				output.WriteString("    " + line + "\n")
			} else {
				output.WriteString("\n")
			}
		}

		output.WriteString("end\n\n")
	}

	// Add loadModule function
	output.WriteString("-- Load module helper function\n")
	output.WriteString("local function loadModule(url)\n")
	output.WriteString("    -- Try embedded module first\n")
	output.WriteString("    if EmbeddedModules[url] then\n")
	output.WriteString("        return EmbeddedModules[url]()\n")
	output.WriteString("    end\n")
	output.WriteString("    \n")
	output.WriteString("    -- Fallback to original require\n")
	output.WriteString("    return require(url)\n")
	output.WriteString("end\n\n")

	// Replace require() and loadstring() in main content
	requireRegex := regexp.MustCompile(`require\s*\(\s*['"]([^'"]+)['"]\s*\)`)
	httpGetRegex := regexp.MustCompile(`loadstring\s*\(\s*game:HttpGet\s*\(\s*['"]([^'"]+)['"]\s*\)\s*\)\s*\(\s*\)`)

	processedMain := mainContent

	// Replace loadstring(game:HttpGet(...))()
	processedMain = httpGetRegex.ReplaceAllStringFunc(processedMain, func(match string) string {
		matches := httpGetRegex.FindStringSubmatch(match)
		if len(matches) > 1 {
			url := matches[1]
			return fmt.Sprintf("loadModule(\"%s\")", escapeString(url))
		}
		return match
	})

	// Replace require() untuk file lokal
	processedMain = requireRegex.ReplaceAllStringFunc(processedMain, func(match string) string {
		matches := requireRegex.FindStringSubmatch(match)
		if len(matches) > 1 {
			modulePath := matches[1]
			if b.isLocalModule(modulePath) {
				return fmt.Sprintf("loadModule(\"%s\")", escapeString(modulePath))
			}
		}
		return match
	})

	output.WriteString("-- Main Script\n")
	output.WriteString(processedMain)

	return output.String()
}

func escapeString(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return s
}

func removeDebugStatements(content string) string {
	lines := strings.Split(content, "\n")
	var result []string

	// Regex patterns untuk mendeteksi print dan warn statements
	printRegex := regexp.MustCompile(`^\s*print\s*\(`)
	warnRegex := regexp.MustCompile(`^\s*warn\s*\(`)

	inMultilineStatement := false
	parenDepth := 0

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Skip empty lines
		if trimmed == "" {
			result = append(result, line)
			continue
		}

		// Cek jika baris ini memulai print/warn statement
		if !inMultilineStatement && (printRegex.MatchString(line) || warnRegex.MatchString(line)) {
			inMultilineStatement = true
			parenDepth = 0

			// Hitung parentheses di baris ini
			for _, char := range line {
				if char == '(' {
					parenDepth++
				} else if char == ')' {
					parenDepth--
				}
			}

			// Jika statement selesai di baris yang sama
			if parenDepth <= 0 {
				inMultilineStatement = false
			}
			continue // Skip baris ini
		}

		// Jika sedang dalam multiline print/warn statement
		if inMultilineStatement {
			for _, char := range line {
				if char == '(' {
					parenDepth++
				} else if char == ')' {
					parenDepth--
				}
			}

			if parenDepth <= 0 {
				inMultilineStatement = false
			}
			continue // Skip baris ini
		}

		// Tambahkan baris yang bukan print/warn
		result = append(result, line)
	}

	return strings.Join(result, "\n")
}

func (b *Bundler) Bundle(entryFile string, release *bool) (string, error) {
	// Baca entry file
	content, err := os.ReadFile(entryFile)
	if err != nil {
		return "", fmt.Errorf("failed to read entry file: %w", err)
	}

	mainContent := string(content)

	// Proses semua dependencies
	fmt.Println("Processing dependencies...")
	if err := b.processFile(entryFile, mainContent); err != nil {
		return "", err
	}

	// Generate bundle
	bundleOutput := b.generateBundle(mainContent)

	// Apply release mode if enabled
	if *release {
		fmt.Println("\nApplying release mode (removing print/warn statements)...")
		bundleOutput = removeDebugStatements(bundleOutput)
	}

	return bundleOutput, nil
}

func main() {
	entryFile := flag.String("entry", "main.lua", "Entry point Lua file")
	outputFile := flag.String("output", "bundle.lua", "Output bundled file")
	release := flag.Bool("release", false, "Release mode: remove print and warn statements")
	flag.Parse()

	baseDir := filepath.Dir(*entryFile)
	if baseDir == "." {
		baseDir, _ = os.Getwd()
	}

	fmt.Printf("Lua Script Bundler\n")
	fmt.Printf("==================\n")
	fmt.Printf("Entry: %s\n", *entryFile)
	fmt.Printf("Output: %s\n", *outputFile)
	if *release {
		fmt.Printf("Mode: Release (print/warn statements will be removed)\n")
	}
	fmt.Println()

	bundler := NewBundler(baseDir)
	result, err := bundler.Bundle(*entryFile, release)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(*outputFile, []byte(result), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to write output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\n✓ Successfully bundled!\n")
	fmt.Printf("✓ Modules embedded: %d\n", len(bundler.modules))
	fmt.Printf("✓ Output: %s\n", *outputFile)
}
